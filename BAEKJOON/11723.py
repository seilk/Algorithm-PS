import sys


def input():
    return sys.stdin.readline().rstrip()


n = int(input())
# 초기화를 꼭 모든 자리수에 0이 있는 것으로 보여야 한다고 생각하지말고 20자리의 0이 있다고 생각하자
# 그런데 모든 자리수가 0인 이진수는 없으니까 그냥 0으로 초기화
s = 0
for i in range(n):
    box = input().split()  # 그냥 str을 원소로 가지는 list로 받음, split()은 return값이 list임
    o = box[0]
    if o == "all" or o == "empty":
        if o == "all":
            s = (1 << 20) - 1  # 21개의 1000...000을 20개의 1111...111로 만듦
        elif o == "empty":
            s = 0
        continue
    x = int(box[1]) - 1  # 인덱스 때문에 -1 해준것임.
    # s = 10000000000 (0이 10개/11자리수)  s - 1 = 1111111111 (1이 10개/10자리수)
    # x = 2이면 뒤에서 2번째 칸을 조사해야한다. 따라서 10으로 조사한다.
    # shift는 n칸 미는것이므로 즉 1뒤에 0을 n개 붙인다고 생각
    # shift로 10을 만드려면 x = 1이어야 한다.
    # 따라서 x = k 이면 100...000이 전체 k자리수가 되어야 하는데 이때 shift는 k - 1을 해줘야 하므로 x 자체를 -1 해주어 shift에 사용한다.
    if o == "add":
        s |= 1 << x  # debug 결과물은 10진수로 나오지만 생각은 2진수 모양으로 해야한다.
    elif o == "remove":
        s &= ~(1 << x)  # s &= (1 << x) - 1
        # ~(100..000) -> 011..111 == (1 << x) - 1
        # 20자리의 s에서 x를 제거할 땐 x를 지목하는 자리부터 나머지 오른쪽 숫자를 비교한다.
        # 1 << x 로 x 위치에 1을 맞춰두고 NOT(~)을 하게 되면 x위치만 0이고 나머지 오른쪽 자리수는 모두 1인 수가 된다.
        # AND연산을 통해서 x위치가 1이라면 0을 출력하게 한다.
        # 키포인트는 x자리보다 왼쪽에 있는 수까지 AND연산을 해줄 필요가 없다는 것이다.
    elif o == "check":
        if s & (1 << x) == 0:
            print(0)
        else:
            print(1)
    elif o == "toggle":  # 0과 1을 바꾸는 작업에는 xor 연산.
        s = s ^ (1 << x)

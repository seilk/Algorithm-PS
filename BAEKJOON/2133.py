import sys
n = int(sys.stdin.readline().rstrip())
# 3 * 1 불가능
# 3 * 2 3가지
# 3 * 3 불가능
# 3 * 4 (3 * 2) 3가지에 3가지 더한것
# 홀수 가로길이 = 불가능
# 짝수 가로길이만 재는데
# 이전의 짝수
# 2 n 타일링 -->
# 10
# 8 + ?
# 2 , 4 , 6 , 8 , 10
dp = [0 for i in range(31)]
dp[2] = 3
# 기본값, dp[4]는 4개 가로칸에서 2개 가로칸을 뺀 dp에서 * 3, 4개 가로칸에서 4개를 빼고 추가된 모양 2개를 더한 값.
dp[4] = 11
for i in range(6, n + 1, 2):
    for j in range(2, i - 1, 2):  # 6 (2, 4) # dp[4] * 2(3)
        if j == i - 2:  # n개를 채울 때 2개의 가로칸을 남겨놓고 채우는 경우 + 새롭게 추가되는 모양 2개(위, 아래)
            dp[i] += dp[j] * 3 + 2
        # 2, 4, 6... 매번 추가되는 모양이 2개씩(위, 아래) 생기는데 이 모양이 들어가는 경우의 수를 항상 고려해야함.
        else:  # 10 -> 2, 4, 6 10 = 4 + 6
            dp[i] += dp[j] * 2  # 10 = 8 + 2 # 8칸짜리 새로운 모양
            # ex) i = 8 에서 i = 6의 새로운 모양 2개를 추가한다고 할 때 남은 칸수는 i = 2이다. 따라서 i = 6의 새로운 모양 2개를 i = 2일 때 경우의 수와 곱해주면 된다.
            # i = 4의 새로운 값 2개는 8 - 4 = 4 이므로 i = 4를 채우는 전체 경우의 수 * 2 를 해주면 된다.
            # 따라서 n칸 이라면 n - 2번째 생기는 새로운 모양, n - 4번째 생기는 새로운 모양, ... n - (n - 2)번째 생기는 새로운 모양까지 고려해서 새로운 모양은 n - (n - 2)번째를 제외하면 항상 2개이므로 남은 칸을 채우는 전체 경우의 수 * 2를 누적해서 더해준다.
            # n - (n - 2)번째 새로 추가되는 모양을 고려하면 3개이다. 이를 j == i - 2에서 보정한다.
print(dp[n])
